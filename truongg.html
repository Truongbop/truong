<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr·∫Øc nghi·ªám L·ªãch s·ª≠ Ph√°t tri·ªÉn Ph·∫ßn m·ªÅm</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: #1e7e34;
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        
        .btn-warning:hover:not(:disabled) {
            background: #d39e00;
            transform: translateY(-2px);
        }
        
        .quiz-info {
            display: flex;
            gap: 20px;
            align-items: center;
            font-weight: 600;
            color: #495057;
            margin-left: auto;
        }
        
        .quiz-content {
            padding: 30px;
        }
        
        .question-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 5px solid #007bff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s ease;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .question-number {
            background: #007bff;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .question-text {
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #212529;
            font-weight: 500;
        }
        
        .options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .option {
            display: flex;
            align-items: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .option:hover {
            border-color: #007bff;
            transform: none;
        }
        
        .option.full-width {
            grid-column: span 2;
        }
        
        .option input[type="radio"],
        .option input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.2);
            cursor: pointer;
        }
        
        .option label {
            cursor: pointer;
            flex: 1;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        .option.correct {
            background-color: #d4edda !important;
            border-color: #28a745 !important;
            color: #155724 !important;
        }
        
        .option.incorrect {
            background-color: #f8d7da !important;
            border-color: #dc3545 !important;
            color: #721c24 !important;
        }
        
        .drop-area .drag-item.correct {
            background-color: #d4edda !important;
        }
        
        .drop-area .drag-item.incorrect {
            background-color: #f8d7da !important;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .results {
            text-align: center;
            padding: 40px;
        }
        
        .results h2 {
            font-size: 2em;
        }
        
        .score {
            font-size: 3em;
            font-weight: bold;
            color: #28a745;
            margin: 20px 0;
        }
        
        .score-details {
            display: flex;
            justify-content: space-around;
            margin: 30px 0;
            gap: 20px;
        }
        
        .score-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            flex: 1;
            border: 2px solid #e9ecef;
        }
        
        .score-item h3 {
            color: #495057;
            margin-bottom: 10px;
        }
        
        .score-item .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #007bff;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 0;
            }
            .container {
                margin: 0;
                border-radius: 0;
                min-height: 100vh;
            }
            .header h1 {
                font-size: 2em;
            }
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            .quiz-info {
                flex-direction: row;
                justify-content: space-around;
                width: 100%;
                margin-top: 10px;
                margin-left: 0;
            }
            .navigation {
                flex-direction: row;
                gap: 15px;
            }
            .score-details {
                flex-direction: column;
            }
            .options {
                grid-template-columns: 1fr;
            }
            .option.full-width {
                grid-column: span 1;
            }
            .drag-drop-container {
                flex-direction: column;
            }
        }
        /* === CSS CHO K√âO TH·∫¢ (DRAG-DROP) === */
        
        .drag-drop-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .drag-items,
        .drop-targets {
            flex: 1;
            min-width: 250px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 1px solid #ddd;
        }
        
        .drag-item {
            background: #e9f5ff;
            border: 1px solid #a0d9ff;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            cursor: grab;
            font-weight: 500;
            transition: background-color 0.2s ease;
            overflow-wrap: break-word;
            word-wrap: break-word;
            line-height: 1.4;
        }
        
        .drag-item:hover {
            background-color: #d1eaff;
        }
        
        .drag-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .drop-target {
            background: #f0f0f0;
            border: 2px dashed #bbb;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            transition: background-color 0.2s, border-color 0.2s;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
        }
        
        .drop-target.over {
            background-color: #e0ffe0;
            border-color: #28a745;
        }
        
        .drop-target .label {
            font-weight: bold;
            color: #333;
            overflow-wrap: break-word;
            word-wrap: break-word;
            line-height: 1.4;
        }
        
        .drop-area {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
            border-radius: 5px;
            background: #e9ecef;
            min-height: 44px;
        }
        /* === CSS CHO ƒêI·ªÄN V√ÄO CH·ªñ TR·ªêNG === */
        
        .fill-in-blanks-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .blank-input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .blank-input-group label {
            font-weight: 600;
            color: #333;
        }
        
        .fill-in-blanks-container input[type="text"] {
            padding: 10px 12px;
            border: 2px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            width: 100%;
            transition: border-color 0.3s ease;
        }
        
        .fill-in-blanks-container input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }
        
        .fill-in-blanks-container input[type="text"].correct {
            border-color: #28a745;
            background-color: #d4edda;
        }
        
        .fill-in-blanks-container input[type="text"].incorrect {
            border-color: #dc3545;
            background-color: #f8d7da;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üìñ Tr·∫Øc nghi·ªám L·ªãch s·ª≠ Ph√°t tri·ªÉn Ph·∫ßn m·ªÅm</h1>
            <p>Ki·ªÉm tra ki·∫øn th·ª©c c·ªßa b·∫°n v·ªÅ qu√° tr√¨nh h√¨nh th√†nh v√† ph√°t tri·ªÉn c·ªßa ng√†nh c√¥ng ngh·ªá ph·∫ßn m·ªÅm.</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <button class="btn btn-primary" id="startBtn" onclick="startQuiz()">B·∫Øt ƒë·∫ßu Quiz</button>
                <button class="btn btn-warning" id="shuffleAllBtn" onclick="shuffleAll()">Tr·ªôn C√¢u h·ªèi & ƒê√°p √°n</button>
                <button class="btn btn-success" id="resetBtn" onclick="resetQuiz()">L√†m l·∫°i</button>
                <div class="quiz-info">
                    <span id="totalQuestionsContainer">T·ªïng s·ªë c√¢u: <strong id="totalQuestions">0</strong></span>
                    <span>Th·ªùi gian: <strong>Kh√¥ng gi·ªõi h·∫°n</strong></span>
                </div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>

        <div class="quiz-content" id="quizContent">
            <div class="question-card">
                <h2 style="text-align: center; color: #6c757d; margin: 50px 0;">
                    Nh·∫•n "B·∫Øt ƒë·∫ßu Quiz" ƒë·ªÉ b·∫Øt ƒë·∫ßu l√†m b√†i
                </h2>
            </div>
        </div>

        <div class="results hidden" id="results">
            <h2>üéâ K·∫øt qu·∫£ Quiz</h2>
            <div class="score" id="finalScore">0/0</div>
            <div class="score-details">
                <div class="score-item">
                    <h3>ƒêi·ªÉm s·ªë</h3>
                    <div class="value" id="percentage">0%</div>
                </div>
                <div class="score-item">
                    <h3>ƒê√∫ng</h3>
                    <div class="value" id="correctCount">0</div>
                </div>
                <div class="score-item">
                    <h3>Sai</h3>
                    <div class="value" id="incorrectCount">0</div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="resetQuiz()">L√†m l·∫°i</button>
        </div>
    </div>

    <script>
        // --- D·ªØ li·ªáu c√¢u h·ªèi ---
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let quizStarted = false;
        let questionsForQuiz = [];
        let originalQuestions = [];

        const allQuestions = [{
            type: "single",
            question: "Ai l√† ng∆∞·ªùi thi·∫øt k·∫ø ra ng√¥n ng·ªØ l·∫≠p tr√¨nh C ‚Äì ng√¥n ng·ªØ c√≥ ·∫£nh h∆∞·ªüng s√¢u r·ªông trong l·∫≠p tr√¨nh h·ªá th·ªëng v√† ph√°t tri·ªÉn ph·∫ßn m·ªÅm?",
            options: [
                "Brian Kernighan v√† Dennis Ritchie",
                "Michael Jackson",
                "Niklaus Wirth",
                "Edsger Dijkstra"
            ],
            correct: [0]
        }, {
            type: "single",
            question: "Theo Dijkstra, ƒëi·ªÅu g√¨ ƒë∆∞·ª£c d√πng ƒë·ªÉ ƒë√°nh gi√° tay ngh·ªÅ c·ªßa m·ªôt l·∫≠p tr√¨nh vi√™n?",
            options: [
                "Th·ªùi gian h·ªç h·ªçc ƒë·∫°i h·ªçc",
                "S·ªë l∆∞·ª£ng module h·ªç c√≥ th·ªÉ vi·∫øt trong m·ªôt ng√†y",
                "M·ª©c ƒë·ªô s·ª≠ d·ª•ng l·ªánh ‚Äúgoto‚Äù ‚Äì c√†ng nhi·ªÅu th√¨ tay ngh·ªÅ c√†ng y·∫øu",
                "S·ªë ng√¥n ng·ªØ l·∫≠p tr√¨nh h·ªç bi·∫øt ‚Äì c√†ng nhi·ªÅu th√¨ tay ngh·ªÅ c√†ng cao"
            ],
            correct: [2]
        }, {
            type: "single",
            question: "M√£ m√°y ƒë∆∞·ª£c xem l√† ng√¥n ng·ªØ l·∫≠p tr√¨nh c∆° b·∫£n v√¨ l√Ω do n√†o sau ƒë√¢y?",
            options: [
                "N√≥ ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng m√£ nh·ªã ph√¢n v√† hi·ªÉu tr·ª±c ti·∫øp b·ªüi ph·∫ßn c·ª©ng m√°y t√≠nh",
                "N√≥ ƒë∆∞·ª£c vi·∫øt b·∫±ng ng√¥n ng·ªØ t·ª± nhi√™n ƒë·ªÉ ng∆∞·ªùi d√πng d·ªÖ hi·ªÉu v√† l·∫≠p tr√¨nh vi√™n d·ªÖ l·∫≠p tr√¨nh",
                "N√≥ ho·∫°t ƒë·ªông nh∆∞ tr√¨nh bi√™n d·ªãch trung gian",
                "N√≥ s·ª≠ d·ª•ng c√°c k√Ω hi·ªáu Latin v√† d·ªÖ ghi nh·ªõ"
            ],
            correct: [0]
        }, {
            type: "single",
            question: "Cu·ªôc kh·ªßng ho·∫£ng ph·∫ßn m·ªÅm trong l·ªãch s·ª≠ ph√°t tri·ªÉn c√¥ng ngh·ªá ph·∫ßn m·ªÅm b·∫Øt ƒë·∫ßu v√†o kho·∫£ng th·ªùi gian n√†o?",
            options: [
                "Cu·ªëi th·∫≠p ni√™n 1960 khi ph·∫ßn m·ªÅm tr·ªü n√™n ph·ª©c t·∫°p h∆°n",
                "Khi m√°y t√≠nh c√° nh√¢n ph·ªï bi·∫øn v√†o ƒë·∫ßu th·∫≠p ni√™n 1980",
                "Trong giai ƒëo·∫°n ƒë·∫ßu th·∫≠p ni√™n 1940 khi m√°y t√≠nh ƒëi·ªán t·ª≠ ra ƒë·ªùi",
                "ƒê·∫ßu th·∫≠p ni√™n 2000 v·ªõi s·ª± xu·∫•t hi·ªán c·ªßa l·∫≠p tr√¨nh web"
            ],
            correct: [0]
        }, {
            type: "single",
            question: "Ng√¥n ng·ªØ l·∫≠p tr√¨nh Pascal ƒë∆∞·ª£c ph√°t tri·ªÉn d·ª±a tr√™n n·ªÅn t·∫£ng c·ªßa ng√¥n ng·ªØ n√†o d∆∞·ªõi ƒë√¢y?",
            options: [
                "Assembly, g·∫ßn v·ªõi m√£ m√°y",
                "C, v·ªõi c√∫ ph√°p ƒë∆°n gi·∫£n v√† m·∫°nh m·∫Ω do Kernighan v√† Ritchie ph√°t tri·ªÉn",
                "ALGOL W, m·ªôt bi·∫øn th·ªÉ c·ªßa ALGOL-60 do Wirth ph√°t tri·ªÉn",
                "BASIC, m·ªôt ng√¥n ng·ªØ d√πng cho ng∆∞·ªùi m·ªõi h·ªçc l·∫≠p tr√¨nh"
            ],
            correct: [2]
        }, {
            type: "single",
            question: "ƒê·∫∑c ƒëi·ªÉm n√†o ƒë√∫ng v·ªõi c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh th·ªùi k·ª≥ ƒë·∫ßu nh∆∞ m√£ m√°y v√† h·ª£p ng·ªØ?",
            options: [
                "C√≥ t√≠nh tr·ª´u t∆∞·ª£ng th·∫•p, kh√≥ hi·ªÉu v√† ph·ª• thu·ªôc v√†o ph·∫ßn c·ª©ng",
                "C√≥ kh·∫£ nƒÉng ch·∫°y tr√™n m·ªçi n·ªÅn t·∫£ng h·ªá ƒëi·ªÅu h√†nh",
                "Ch√∫ng c√≥ t√≠nh tr·ª´u t∆∞·ª£ng cao, d·ªÖ ƒë·ªçc, d·ªÖ v·∫≠n h√†nh v√† d·ªÖ b·∫£o tr√¨",
                "ƒê∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ ƒë·ªôc l·∫≠p v·ªõi ph·∫ßn c·ª©ng"
            ],
            correct: [0]
        }, {
            type: "single",
            question: "Cu·ªôc kh·ªßng ho·∫£ng ph·∫ßn m·ªÅm ƒë√£ d·∫´n ƒë·∫øn s·ª± ra ƒë·ªùi v√† ph√°t tri·ªÉn m·∫°nh m·∫Ω c·ªßa lƒ©nh v·ª±c n√†o trong c√¥ng ngh·ªá th√¥ng tin?",
            options: [
                "Ph·∫ßn c·ª©ng m√°y t√≠nh c√° nh√¢n",
                "Tr√≠ tu·ªá nh√¢n t·∫°o ·ª©ng d·ª•ng trong ph·∫ßn m·ªÅm",
                "C√¥ng ngh·ªá ph·∫ßn m·ªÅm, v·ªõi c√°c ph∆∞∆°ng ph√°p ph√°t tri·ªÉn c√≥ t·ªï ch·ª©c",
                "C√¥ng ngh·ªá m·∫°ng v√† truy·ªÅn th√¥ng, v·ªõi h·ªá th·ªëng m·∫°ng internet ph√°t tri·ªÉn"
            ],
            correct: [2]
        }, {
            type: "single",
            question: "M·ª•c ti√™u cu·ªëi c√πng c·ªßa k·ªπ thu·∫≠t l·∫≠p tr√¨nh v√† c√¥ng ngh·ªá ph·∫ßn m·ªÅm l√† g√¨?",
            options: [
                "T·ªëi ∆∞u h√≥a s·ª± ph·ªëi h·ª£p gi·ªØa con ng∆∞·ªùi v√† m√°y t√≠nh",
                "Gi·∫£m chi ph√≠ ph·∫ßn m·ªÅm ƒë·∫øn m·ª©c t·ªëi thi·ªÉu",
                "Lo·∫°i b·ªè ho√†n to√†n l·ªói trong ch∆∞∆°ng tr√¨nh",
                "X√¢y d·ª±ng ph·∫ßn m·ªÅm ch·ªâ d√πng m·ªôt ng√¥n ng·ªØ l·∫≠p tr√¨nh"
            ],
            correct: [0]
        }, {
            type: "multiple",
            question: "C√¥ng c·ª• v√† ph∆∞∆°ng ph√°p n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ph·ªï bi·∫øn ƒë·ªÉ nh·∫≠p ch∆∞∆°ng tr√¨nh v√†o m√°y t√≠nh trong nh·ªØng nƒÉm 1950‚Äì1970? (Ch·ªçn 2 ƒë√°p √°n ƒë√∫ng)",
            options: [
                "M√°y ƒë·ª•c th·∫ª (punch card machine) do Herman Hollerith ph√°t minh",
                "Nh·∫≠p l·ªánh b·∫±ng b√†n ph√≠m c∆° v√† l∆∞u tr·ªØ tr·ª±c ti·∫øp qua ·ªï c·ª©ng SSD",
                "S·ª≠ d·ª•ng tr√¨nh so·∫°n th·∫£o vƒÉn b·∫£n nh∆∞ Notepad k·∫øt h·ª£p h·ªá ƒëi·ªÅu h√†nh d√≤ng l·ªánh",
                "Th·∫ª ƒë·ª•c l·ªó v·ªõi m·ªói l·ªó ƒë·∫°i di·ªán cho m·ªôt k√Ω t·ª± m√£ h√≥a"
            ],
            correct: [0, 3]
        }, {
            type: "multiple",
            question: "Theo quy tr√¨nh ph√°t tri·ªÉn ph·∫ßn m·ªÅm hi·ªán ƒë·∫°i ƒë∆∞·ª£c h√¨nh th√†nh sau kh·ªßng ho·∫£ng, hai y·∫øu t·ªë n√†o sau ƒë√¢y l√† then ch·ªët ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng s·∫£n ph·∫©m? (Ch·ªçn 2 ƒë√°p √°n ƒë√∫ng)",
            options: [
                "Ch·ªâ ki·ªÉm th·ª≠ ph·∫ßn m·ªÅm sau khi tri·ªÉn khai ƒë·ªÉ ti·∫øt ki·ªám th·ªùi gian ph√°t tri·ªÉn",
                "T·ªï ch·ª©c h·ª£p t√°c nh√≥m gi·ªØa c√°c vai tr√≤ kh√°c nhau nh∆∞ l·∫≠p tr√¨nh vi√™n, ki·ªÉm th·ª≠ vi√™n, v√† ph√¢n t√≠ch vi√™n",
                "Thi·∫øt k·∫ø h·ªá th·ªëng ho√†n to√†n do m·ªôt l·∫≠p tr√¨nh vi√™n k·ª≥ c·ª±u th·ª±c hi·ªán",
                "Ph√¢n chia ch·ª©c nƒÉng ph·∫ßn m·ªÅm th√†nh c√°c module t∆∞∆°ng ƒë·ªëi ƒë·ªôc l·∫≠p"
            ],
            correct: [1, 3]
        }, {
            type: "single",
            question: "ENIAC l√† v√≠ d·ª• ƒëi·ªÉn h√¨nh cho lo·∫°i m√°y t√≠nh n√†o sau ƒë√¢y?",
            options: [
                "M√°y t√≠nh c√° nh√¢n th·∫ø h·ªá m·ªõi c√≥ kh·∫£ nƒÉng t·ª± h·ªçc nh·ªù tr√≠ tu·ªá nh√¢n t·∫°o",
                "M√°y t√≠nh c√° nh√¢n ƒë·∫ßu ti√™n c·ªßa th·∫ø gi·ªõi",
                "M√°y t√≠nh c√≥ h·ªá ƒëi·ªÅu h√†nh hi·ªán ƒë·∫°i nh∆∞ Windows",
                "M√°y t√≠nh l·∫≠p tr√¨nh c·ªë ƒë·ªãnh, l·∫≠p tr√¨nh b·∫±ng d√¢y c√°p v√† c√¥ng t·∫Øc"
            ],
            correct: [3]
        }, {
            type: "multiple",
            question: "Trong c√°c y·∫øu t·ªë sau, y·∫øu t·ªë n√†o l√† nguy√™n nh√¢n tr·ª±c ti·∫øp d·∫´n ƒë·∫øn cu·ªôc kh·ªßng ho·∫£ng ph·∫ßn m·ªÅm v√†o cu·ªëi th·∫≠p ni√™n 1960? (Ch·ªçn 2 ƒë√°p √°n ƒë√∫ng)",
            options: [
                "ƒê·ªô ph·ª©c t·∫°p tƒÉng cao do ph·∫ßn m·ªÅm ng√†y c√†ng l·ªõn trong khi k·ªπ thu·∫≠t ph√°t tri·ªÉn kh√¥ng theo k·ªãp",
                "C√°c c√¥ng c·ª• bi√™n d·ªãch v√† ki·ªÉm th·ª≠ ƒë√£ qu√° ph·ª©c t·∫°p, g√¢y kh√≥ khƒÉn trong s·ª≠ d·ª•ng",
                "H·ªá ƒëi·ªÅu h√†nh kh√¥ng h·ªó tr·ª£ ƒë·ªß t√≠nh nƒÉng ƒëa nhi·ªám khi·∫øn ph·∫ßn m·ªÅm d·ªÖ treo m√°y",
                "Thi·∫øu c√°c ph∆∞∆°ng ph√°p ph√°t tri·ªÉn ph·∫ßn m·ªÅm c√≥ h·ªá th·ªëng v√† quy tr√¨nh chu·∫©n h√≥a"
            ],
            correct: [0, 3]
        }, {
            type: "multiple",
            question: "Nh·ªØng t∆∞ t∆∞·ªüng l·∫≠p tr√¨nh n√†o d∆∞·ªõi ƒë√¢y ph·∫£n √°nh ƒë√∫ng tinh th·∫ßn c√°ch m·∫°ng xu·∫•t hi·ªán sau cu·ªôc kh·ªßng ho·∫£ng ph·∫ßn m·ªÅm? (Ch·ªçn 2 ƒë√°p √°n ƒë√∫ng)",
            options: [
                "Ch√∫ tr·ªçng ƒë·∫øn t√≠nh ƒë√∫ng ƒë·∫Øn, d·ªÖ hi·ªÉu v√† d·ªÖ b·∫£o tr√¨ c·ªßa ch∆∞∆°ng tr√¨nh",
                "T√°ch b√†i to√°n l·ªõn th√†nh c√°c ph·∫ßn nh·ªè h∆°n c√≥ th·ªÉ gi·∫£i quy·∫øt ƒë·ªôc l·∫≠p",
                "∆Øu ti√™n l·∫≠p tr√¨nh b·∫±ng ng√¥n ng·ªØ c√†ng g·∫ßn v·ªõi m√£ m√°y c√†ng t·ªët ƒë·ªÉ tƒÉng hi·ªáu nƒÉng",
                "Tr√°nh s·ª≠ d·ª•ng c·∫•u tr√∫c ƒëi·ªÅu khi·ªÉn c√≥ ƒëi·ªÅu ki·ªán ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a m√£ ngu·ªìn"
            ],
            correct: [0, 1]
        }, {
            type: "single",
            question: "Trong th·ªùi k·ª≥ ƒë·∫ßu ph√°t tri·ªÉn c·ªßa tin h·ªçc, ng√¥n ng·ªØ l·∫≠p tr√¨nh n√†o ƒë∆∞·ª£c s·ª≠ d·ª•ng ph·ªï bi·∫øn nh·∫•t ƒë·ªÉ vi·∫øt ch∆∞∆°ng tr√¨nh ƒëi·ªÅu khi·ªÉn m√°y t√≠nh?",
            options: [
                "Ng√¥n ng·ªØ C++, h·ªó tr·ª£ l·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng",
                "Ng√¥n ng·ªØ Java, th∆∞·ªùng d√πng trong c√°c ·ª©ng d·ª•ng di ƒë·ªông",
                "C√°c ng√¥n ng·ªØ b·∫≠c th·∫•p nh∆∞ m√£ m√°y v√† h·ª£p ng·ªØ",
                "Ng√¥n ng·ªØ Python, v·ªõi c√∫ ph√°p hi·ªán ƒë·∫°i v√† d·ªÖ h·ªçc"
            ],
            correct: [2]
        }, {
            type: "drag-drop",
            question: "Gh√©p giai ƒëo·∫°n quy tr√¨nh s·∫£n xu·∫•t ph·∫ßn m·ªÅm v·ªõi ng∆∞·ªùi th·ª±c hi·ªán t∆∞∆°ng ·ª©ng.",
            dragItems: ["Giai ƒëo·∫°n 1-4", "Giai ƒëo·∫°n 5", "Giai ƒëo·∫°n 6", "Giai ƒëo·∫°n 7", "Giai ƒëo·∫°n 8"],
            dropTargets: [{
                label: "Kh·∫£o s√°t vi√™n",
                correct: "Giai ƒëo·∫°n 1-4"
            }, {
                label: "Ph√¢n t√≠ch vi√™n",
                correct: "Giai ƒëo·∫°n 5"
            }, {
                label: "L·∫≠p tr√¨nh vi√™n",
                correct: "Giai ƒëo·∫°n 6"
            }, {
                label: "Chuy√™n vi√™n l·∫≠p tr√¨nh tr∆∞·ªüng",
                correct: "Giai ƒëo·∫°n 7"
            }, {
                label: "Chuy√™n vi√™n ki·ªÉm th·ª≠",
                correct: "Giai ƒëo·∫°n 8"
            }, ]
        }, {
            type: "group-radio",
            question: "ƒê√°nh gi√° t√≠nh ƒë√∫ng/sai c·ªßa c√°c nh·∫≠n ƒë·ªãnh sau v·ªÅ ph∆∞∆°ng ph√°p l·∫≠p tr√¨nh th·ªß c√¥ng trong giai ƒëo·∫°n ƒë·∫ßu ph√°t tri·ªÉn m√°y t√≠nh:",
            subQuestions: [{
                stem: "1) Trong th·ªùi k·ª≥ n√†y, vi·ªác l·∫≠p tr√¨nh ƒë∆∞·ª£c th·ª±c hi·ªán tr·ª±c ti·∫øp tr√™n thi·∫øt b·ªã th√¥ng qua b√†n ph√≠m v√† m√†n h√¨nh CRT.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 1
            }, {
                stem: "2) ENIAC ‚Äì m·ªôt trong nh·ªØng m√°y t√≠nh ƒë·∫ßu ti√™n ‚Äì ƒë√£ ƒë∆∞·ª£c t√≠ch h·ª£p ng√¥n ng·ªØ l·∫≠p tr√¨nh b·∫≠c cao nh∆∞ Fortran ƒë·ªÉ h·ªó tr·ª£ ng∆∞·ªùi l·∫≠p tr√¨nh.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 1
            }, {
                stem: "3) Th·∫ª ƒë·ª•c l·ªó l√† c√¥ng c·ª• nh·∫≠p ch∆∞∆°ng tr√¨nh ph·ªï bi·∫øn, m·ªói l·ªó t∆∞∆°ng ·ª©ng v·ªõi m·ªôt k√Ω t·ª± hay l·ªánh m√£ h√≥a.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 0
            }, {
                stem: "4) L·∫≠p tr√¨nh vi√™n th·ªùi k·ª≥ ƒë·∫ßu th∆∞·ªùng l√†m vi·ªác ƒë∆°n l·∫ª, thi·∫øu s·ª± ph√¢n chia r√µ r√†ng vai tr√≤ v√† ph·ªëi h·ª£p nh√≥m.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 0
            }]
        }, {
            type: "group-radio",
            question: "X√°c ƒë·ªãnh c√°c ph√°t bi·ªÉu ƒë√∫ng/sai v·ªÅ t∆∞ t∆∞·ªüng l·∫≠p tr√¨nh hi·ªán ƒë·∫°i v√† quan ƒëi·ªÉm c·ªßa c√°c nh√† khoa h·ªçc:",
            subQuestions: [{
                stem: "1) Pascal l√† m·ªôt ng√¥n ng·ªØ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë∆°n gi·∫£n, ph√π h·ª£p ƒë·ªÉ gi·∫£ng d·∫°y c√°c nguy√™n l√Ω l·∫≠p tr√¨nh c√≥ c·∫•u tr√∫c.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 0
            }, {
                stem: "2) Tony Hoare ƒë√£ ƒë√≥ng g√≥p c√°c ti√™n ƒë·ªÅ ch·ª©ng minh t√≠nh ƒë√∫ng ƒë·∫Øn ch∆∞∆°ng tr√¨nh, g√≥p ph·∫ßn v√†o l√Ω thuy·∫øt l·∫≠p tr√¨nh hi·ªán ƒë·∫°i.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 0
            }, {
                stem: "3) L·ªánh ‚Äúgoto‚Äù ƒë∆∞·ª£c khuy·∫øn kh√≠ch s·ª≠ d·ª•ng trong l·∫≠p tr√¨nh hi·ªán ƒë·∫°i v√¨ n√≥ gi√∫p ch∆∞∆°ng tr√¨nh r√µ r√†ng h∆°n.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 1
            }, {
                stem: "4) Dijkstra cho r·∫±ng c√°c v√≤ng l·∫∑p v√† r·∫Ω nh√°nh l√† nguy√™n nh√¢n l√†m ch∆∞∆°ng tr√¨nh sai, n√™n c·∫ßn tr√°nh s·ª≠ d·ª•ng ho√†n to√†n.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 1
            }]
        }, {
            type: "group-radio",
            question: "X√°c ƒë·ªãnh c√°c ph√°t bi·ªÉu ƒë√∫ng/sai li√™n quan ƒë·∫øn quy tr√¨nh c√¥ng ngh·ªá ph·∫ßn m·ªÅm v√† vai tr√≤ c√°c chuy√™n vi√™n:",
            subQuestions: [{
                stem: "1) Quy tr√¨nh s·∫£n xu·∫•t ph·∫ßn m·ªÅm theo c√¥ng ngh·ªá th√¥ng th∆∞·ªùng bao g·ªìm 9 giai ƒëo·∫°n r√µ r√†ng, t·ª´ ph√¢n t√≠ch ƒë·∫øn thu th·∫≠p ph·∫£n h·ªìi.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 0
            }, {
                stem: "2) Giai ƒëo·∫°n 6 ‚Äì chuy√™n gia l·∫≠p tr√¨nh tr∆∞·ªüng ‚Äì l√† ng∆∞·ªùi th·ª±c hi·ªán ki·ªÉm th·ª≠ ph·∫ßn m·ªÅm tr∆∞·ªõc khi giao cho kh√°ch h√†ng.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 1
            }, {
                stem: "3) Vi·ªác ph√¢n t√≠ch y√™u c·∫ßu v√† thi·∫øt k·∫ø ph·∫ßn m·ªÅm l√† tr√°ch nhi·ªám ch√≠nh c·ªßa c√°c l·∫≠p tr√¨nh vi√™n ngay t·ª´ ƒë·∫ßu quy tr√¨nh.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 1
            }, {
                stem: "4) Trong giai ƒëo·∫°n m√£ h√≥a, l·∫≠p tr√¨nh vi√™n n√™n t·∫≠n d·ª•ng c√°c thu·∫≠t to√°n ho·∫∑c th·ªß t·ª•c c√≥ s·∫µn ƒë·ªÉ tƒÉng hi·ªáu qu·∫£ ph√°t tri·ªÉn.",
                options: ["ƒê√∫ng", "Sai"],
                correct: 0
            }]
        }, {
            type: "fill-in-blanks",
            question: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o c√¢u sau: Trong th·ªùi k·ª≥ ƒë·∫ßu c·ªßa __(1)__ , __(2)__ th∆∞·ªùng vi·∫øt m√£ b·∫±ng tay tr√™n __(3)__ , sau ƒë√≥ nh·∫≠p v√†o m√°y th√¥ng qua __(4)__ ho·∫∑c c√¥ng t·∫Øc.",
            blanks: [{
                label: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o ch·ªó tr·ªëng (1)",
                answer: "tin h·ªçc"
            }, {
                label: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o ch·ªó tr·ªëng (2)",
                answer: "l·∫≠p tr√¨nh vi√™n"
            }, {
                label: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o ch·ªó tr·ªëng (3)",
                answer: "gi·∫•y"
            }, {
                label: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o ch·ªó tr·ªëng (4)",
                answer: "th·∫ª ƒë·ª•c l·ªó"
            }, ]
        }, {
            type: "fill-in-blanks",
            question: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o c√¢u sau: M·ªôt trong nh·ªØng ___(1)___ ch√≠nh d·∫´n ƒë·∫øn cu·ªôc kh·ªßng ho·∫£ng ___(2)___ l√† do s·∫£n xu·∫•t ph·∫ßn m·ªÅm mang t√≠nh ___(3)___ v√† thi·∫øu t√≠nh ___(4)___.",
            blanks: [{
                label: "ƒêi·ªÅn t·ª´ c√≤n thi·∫øu v√†o √¥ tr·ªëng (1)",
                answer: "nguy√™n nh√¢n"
            }, {
                label: "ƒêi·ªÅn t·ª≠ c√≤n thi·∫øu v√†o √¥ tr·ªëng (2)",
                answer: "ph·∫ßn m·ªÅm"
            }, {
                label: "ƒêi·ªÅn t·ª≠ c√≤n thi·∫øu v√†o √¥ tr·ªëng (3)",
                answer: "th·ªß c√¥ng"
            }, {
                label: "ƒêi·ªÅn t·ª≠ c√≤n thi·∫øu v√†o √¥ tr·ªëng (4)",
                answer: "chuy√™n nghi·ªáp"
            }, ]
        }, ];


        // --- Kh·ªüi t·∫°o v√† DOM Elements ---
        document.addEventListener('DOMContentLoaded', initialize);

        function initialize() {
            originalQuestions = JSON.parse(JSON.stringify(allQuestions));
            questionsForQuiz = JSON.parse(JSON.stringify(originalQuestions));
            document.getElementById('totalQuestions').textContent = questionsForQuiz.length;
            document.getElementById('resetBtn').disabled = true;
            document.getElementById('shuffleAllBtn').disabled = false;
        }

        // --- H√†m ƒëi·ªÅu khi·ªÉn Quiz ---
        function startQuiz() {
            quizStarted = true;
            currentQuestionIndex = 0;
            userAnswers = new Array(questionsForQuiz.length).fill(null);
            document.getElementById('startBtn').disabled = true;
            document.getElementById('shuffleAllBtn').disabled = true;
            document.getElementById('resetBtn').disabled = false;
            displayQuestion();
        }

        function resetQuiz() {
            quizStarted = false;
            currentQuestionIndex = 0;
            userAnswers = [];
            questionsForQuiz = JSON.parse(JSON.stringify(originalQuestions));
            document.getElementById('quizContent').innerHTML = `
            <div class="question-card">
                <h2 style="text-align: center; color: #6c757d; margin: 50px 0;">
                    Nh·∫•n "B·∫Øt ƒë·∫ßu Quiz" ƒë·ªÉ b·∫Øt ƒë·∫ßu l√†m b√†i
                </h2>
            </div>`;
            document.getElementById('results').classList.add('hidden');
            document.getElementById('quizContent').classList.remove('hidden');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('shuffleAllBtn').disabled = false;
            document.getElementById('resetBtn').disabled = true;
            updateProgressBar();
        }

        function shuffleAll() {
            for (let i = questionsForQuiz.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [questionsForQuiz[i], questionsForQuiz[j]] = [questionsForQuiz[j], questionsForQuiz[i]];
            }

            questionsForQuiz.forEach(q => {
                if ((q.type === 'single' || q.type === 'multiple') && q.options) {
                    const optionsWithAnswers = q.options.map((option, index) => ({
                        text: option,
                        isCorrect: q.correct.includes(index)
                    }));

                    for (let i = optionsWithAnswers.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [optionsWithAnswers[i], optionsWithAnswers[j]] = [optionsWithAnswers[j], optionsWithAnswers[i]];
                    }

                    q.options = optionsWithAnswers.map(item => item.text);
                    q.correct = optionsWithAnswers.map((item, index) => item.isCorrect ? index : -1).filter(index => index !== -1);
                }
            });

            alert("ƒê√£ tr·ªôn c√¢u h·ªèi v√† ƒë√°p √°n!");
        }

        function saveAnswer() {
            if (!quizStarted) return;
            const questionData = questionsForQuiz[currentQuestionIndex];
            const questionCard = document.querySelector('.question-card');
            if (!questionCard) return;

            let currentAnswer = null;

            switch (questionData.type) {
                case 'single':
                case 'multiple':
                    const selectedOptions = Array.from(questionCard.querySelectorAll('input:checked')).map(input => parseInt(input.value));
                    if (selectedOptions.length > 0) {
                        currentAnswer = selectedOptions;
                    }
                    break;

                case 'group-radio':
                    const subAnswers = [];
                    const groups = questionCard.querySelectorAll('.option-group');
                    let allAnswered = true;
                    groups.forEach((group, index) => {
                        const checkedRadio = group.querySelector('input:checked');
                        if (checkedRadio) {
                            subAnswers[index] = parseInt(checkedRadio.value);
                        } else {
                            subAnswers[index] = null;
                        }
                    });
                    if (subAnswers.some(ans => ans !== null)) {
                        currentAnswer = subAnswers;
                    }
                    break;

                case 'fill-in-blanks':
                    const inputs = Array.from(questionCard.querySelectorAll('input[type="text"]'));
                    const filledAnswers = inputs.map(input => input.value.trim());
                    if (filledAnswers.some(ans => ans !== '')) {
                        currentAnswer = filledAnswers;
                    }
                    break;

                case 'drag-drop':
                    const dropAreas = Array.from(questionCard.querySelectorAll('.drop-area'));
                    const droppedAnswers = dropAreas.map(area => {
                        const item = area.querySelector('.drag-item'); // 1. T√¨m ph·∫ßn t·ª≠ tr∆∞·ªõc v√† l∆∞u v√†o bi·∫øn 'item'
                        return item ? item.textContent.trim() : null; // 2. N·∫øu c√≥ 'item', l·∫•y textContent c·ªßa n√≥. N·∫øu kh√¥ng, tr·∫£ v·ªÅ null.
                    });
                    if (droppedAnswers.some(ans => ans !== null)) {
                        currentAnswer = droppedAnswers;
                    }
                    break;
            }

            userAnswers[currentQuestionIndex] = currentAnswer;
        }

        function displayQuestion() {
            const quizContent = document.getElementById('quizContent');
            const questionData = questionsForQuiz[currentQuestionIndex];
            quizContent.innerHTML = '';

            const card = document.createElement('div');
            card.className = 'question-card';

            card.innerHTML = `
            <div class="question-header">
                <span class="question-number">C√¢u ${currentQuestionIndex + 1} / ${questionsForQuiz.length}</span>
            </div>
            <p class="question-text">${questionData.question}</p>
            `;

            switch (questionData.type) {
                case 'single':
                case 'multiple':
                    card.appendChild(createOptions(questionData));
                    break;
                case 'group-radio':
                    card.appendChild(createGroupRadio(questionData));
                    break;
                case 'drag-drop':
                    card.appendChild(createDragDrop(questionData));
                    break;
                case 'fill-in-blanks':
                    card.appendChild(createFillInBlanks(questionData));
                    break;
            }

            card.appendChild(createNavigation());
            quizContent.appendChild(card);

            if (questionData.type === 'drag-drop') {
                initializeDragDrop();
            }

            updateProgressBar();
        }

        function createOptions(questionData) {
            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'options';
            const savedAnswer = userAnswers[currentQuestionIndex];

            questionData.options.forEach((optionText, index) => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'option';
                if (questionData.options.length % 2 !== 0 && index === questionData.options.length - 1) {
                    optionDiv.classList.add('full-width');
                }

                const inputType = questionData.type === 'single' ? 'radio' : 'checkbox';
                const input = document.createElement('input');
                input.type = inputType;
                input.name = `question-${currentQuestionIndex}`;
                input.value = index;
                input.id = `q${currentQuestionIndex}-op${index}`;

                if (savedAnswer && savedAnswer.includes(index)) {
                    input.checked = true;
                }

                const label = document.createElement('label');
                label.htmlFor = `q${currentQuestionIndex}-op${index}`;
                label.textContent = optionText;

                optionDiv.appendChild(input);
                optionDiv.appendChild(label);
                optionsContainer.appendChild(optionDiv);
            });
            return optionsContainer;
        }

        function createGroupRadio(questionData) {
            const container = document.createElement('div');
            container.className = 'group-radio-container';
            const savedSubAnswers = userAnswers[currentQuestionIndex];

            questionData.subQuestions.forEach((sub, subIndex) => {
                const subContainer = document.createElement('div');
                subContainer.className = 'option-group';
                subContainer.style.marginBottom = '15px';

                const stem = document.createElement('p');
                stem.textContent = sub.stem;
                stem.style.marginBottom = '8px';
                stem.style.fontWeight = '500';
                subContainer.appendChild(stem);

                const optionsDiv = document.createElement('div');
                optionsDiv.style.display = 'flex';
                optionsDiv.style.gap = '20px';

                sub.options.forEach((opt, optIndex) => {
                    const optionWrapper = document.createElement('div');
                    optionWrapper.style.display = 'flex';
                    optionWrapper.style.alignItems = 'center';

                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = `question-${currentQuestionIndex}-sub-${subIndex}`;
                    input.value = optIndex;
                    input.id = `q${currentQuestionIndex}-s${subIndex}-op${optIndex}`;

                    if (savedSubAnswers && savedSubAnswers[subIndex] === optIndex) {
                        input.checked = true;
                    }

                    const label = document.createElement('label');
                    label.htmlFor = input.id;
                    label.textContent = opt;
                    label.style.marginLeft = '8px';

                    optionWrapper.appendChild(input);
                    optionWrapper.appendChild(label);
                    optionsDiv.appendChild(optionWrapper);
                });
                subContainer.appendChild(optionsDiv);
                container.appendChild(subContainer);
            });
            return container;
        }

        function createFillInBlanks(questionData) {
            const container = document.createElement('div');
            container.className = 'fill-in-blanks-container';
            const savedAnswer = userAnswers[currentQuestionIndex];

            questionData.blanks.forEach((blank, index) => {
                const group = document.createElement('div');
                group.className = 'blank-input-group';

                const label = document.createElement('label');
                label.htmlFor = `q${currentQuestionIndex}-blank${index}`;
                label.textContent = blank.label;

                const input = document.createElement('input');
                input.type = 'text';
                input.id = `q${currentQuestionIndex}-blank${index}`;
                input.placeholder = `ƒêi·ªÅn v√†o √¥ tr·ªëng (${index + 1})...`;

                if (savedAnswer && savedAnswer[index]) {
                    input.value = savedAnswer[index];
                }

                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            });
            return container;
        }

        function createDragDrop(questionData) {
            const container = document.createElement('div');
            container.className = 'drag-drop-container';

            const dragSource = document.createElement('div');
            dragSource.className = 'drag-items';
            dragSource.innerHTML = '<h4>K√©o t·ª´ ƒë√¢y:</h4>';

            const dropTargetContainer = document.createElement('div');
            dropTargetContainer.className = 'drop-targets';
            dropTargetContainer.innerHTML = '<h4>Th·∫£ v√†o ƒë√¢y:</h4>';

            const savedAnswer = userAnswers[currentQuestionIndex];
            const usedDragItems = savedAnswer ? [...savedAnswer] : [];

            questionData.dropTargets.forEach((target, index) => {
                const dropTarget = document.createElement('div');
                dropTarget.className = 'drop-target';
                dropTarget.innerHTML = `<span class="label">${target.label}</span>`;

                const dropArea = document.createElement('div');
                dropArea.className = 'drop-area';
                dropArea.dataset.targetIndex = index;

                if (savedAnswer && savedAnswer[index]) {
                    const itemText = savedAnswer[index];
                    const dragItem = document.createElement('div');
                    dragItem.className = 'drag-item';
                    dragItem.textContent = itemText;
                    dragItem.draggable = true;
                    dragItem.id = `q${currentQuestionIndex}-drag-${itemText.replace(/\s/g, '-')}`;
                    dropArea.appendChild(dragItem);
                }

                dropTarget.appendChild(dropArea);
                dropTargetContainer.appendChild(dropTarget);
            });

            questionData.dragItems.forEach(itemText => {
                if (!usedDragItems.includes(itemText)) {
                    const dragItem = document.createElement('div');
                    dragItem.className = 'drag-item';
                    dragItem.textContent = itemText;
                    dragItem.draggable = true;
                    dragItem.id = `q${currentQuestionIndex}-drag-${itemText.replace(/\s/g, '-')}`;
                    dragSource.appendChild(dragItem);
                }
            });

            container.appendChild(dragSource);
            container.appendChild(dropTargetContainer);
            return container;
        }

        function createNavigation() {
            const nav = document.createElement('div');
            nav.className = 'navigation';

            const prevBtn = document.createElement('button');
            prevBtn.textContent = 'C√¢u tr∆∞·ªõc';
            prevBtn.className = 'btn btn-primary';
            prevBtn.onclick = prevQuestion;
            prevBtn.disabled = currentQuestionIndex === 0;

            const nextBtn = document.createElement('button');
            nextBtn.className = 'btn btn-primary';

            if (currentQuestionIndex < questionsForQuiz.length - 1) {
                nextBtn.textContent = 'C√¢u sau';
                nextBtn.onclick = nextQuestion;
            } else {
                nextBtn.textContent = 'N·ªôp b√†i';
                nextBtn.className = 'btn btn-success';
                nextBtn.onclick = submitQuiz;
            }

            nav.appendChild(prevBtn);
            nav.appendChild(nextBtn);
            return nav;
        }

        function nextQuestion() {
            saveAnswer();
            if (currentQuestionIndex < questionsForQuiz.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            }
        }

        function prevQuestion() {
            saveAnswer();
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        }

        function submitQuiz() {
            saveAnswer();
            calculateResults();
        }

        function calculateResults() {
            let correctAnswersCount = 0;
            questionsForQuiz.forEach((question, index) => {
                const userAnswer = userAnswers[index];
                if (!userAnswer) return;

                let isCorrect = false;
                switch (question.type) {
                    case 'single':
                        isCorrect = userAnswer[0] === question.correct[0];
                        break;
                    case 'multiple':
                        isCorrect = question.correct.length === userAnswer.length &&
                            question.correct.every(val => userAnswer.includes(val));
                        break;
                    case 'group-radio':
                        isCorrect = userAnswer.every((ans, i) => ans === question.subQuestions[i].correct);
                        break;
                    case 'fill-in-blanks':
                        isCorrect = userAnswer.every((ans, i) => ans.toLowerCase() === question.blanks[i].answer.toLowerCase());
                        break;
                    case 'drag-drop':
                        const correctDropAnswers = question.dropTargets.map(t => t.correct);
                        isCorrect = userAnswer.every((ans, i) => ans === correctDropAnswers[i]);
                        break;
                }

                if (isCorrect) {
                    correctAnswersCount++;
                }
            });

            displayResults(correctAnswersCount);
        }

        function displayResults(correctCount) {
            const total = questionsForQuiz.length;
            const incorrectCount = total - correctCount;
            const percentage = total > 0 ? Math.round((correctCount / total) * 100) : 0;

            document.getElementById('quizContent').classList.add('hidden');
            document.getElementById('results').classList.remove('hidden');

            document.getElementById('finalScore').textContent = `${correctCount} / ${total}`;
            document.getElementById('percentage').textContent = `${percentage}%`;
            document.getElementById('correctCount').textContent = correctCount;
            document.getElementById('incorrectCount').textContent = incorrectCount;
        }

        function updateProgressBar() {
            const progress = quizStarted ? ((currentQuestionIndex) / questionsForQuiz.length) * 100 : 0;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }


        function initializeDragDrop() {
            const draggables = document.querySelectorAll('.drag-item');
            const dropAreas = document.querySelectorAll('.drop-area');
            const dragSource = document.querySelector('.drag-items');

            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', () => {
                    draggable.classList.add('dragging');
                });
                draggable.addEventListener('dragend', () => {
                    draggable.classList.remove('dragging');
                });
            });

            dropAreas.forEach(area => {
                area.addEventListener('dragover', e => {
                    e.preventDefault();
                    if (!area.hasChildNodes()) {
                        area.parentElement.classList.add('over');
                    }
                });
                area.addEventListener('dragleave', () => {
                    area.parentElement.classList.remove('over');
                });
                area.addEventListener('drop', e => {
                    e.preventDefault();
                    area.parentElement.classList.remove('over');
                    const draggingItem = document.querySelector('.dragging');
                    if (draggingItem && !area.hasChildNodes()) {
                        area.appendChild(draggingItem);
                    }
                });
            });

            if (dragSource) {
                dragSource.addEventListener('dragover', e => e.preventDefault());
                dragSource.addEventListener('drop', e => {
                    e.preventDefault();
                    const draggingItem = document.querySelector('.dragging');
                    if (draggingItem) {
                        dragSource.appendChild(draggingItem);
                    }
                });
            }
        }
    </script>

</body>

</html>
